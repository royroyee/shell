# Basic


### 1. 계산(bc)
```shell
$ echo '1+1' | bc
2
```
- `|` : **pipe**, 왼쪽 명령어의 출력을 오른쪽 명령어로 전달

### 2. 파일에 저장(>)
```shell
$ echo '1+1' | bc > a
```
- bc의 결과를 a 라는 파일에 저장
- `>` : 리다이렉트, 터미널 화면에 출력할 명령어의 결과를 다른 대상으로 돌린다.
- ls, cat 명령어등을 활용하여 새로 생긴 파일 a 확인 가능
  - `cat` : 지정한 파일의 내용을 그대로 출력
  - `ls -l` : `ls`보다 자세한 파일 정보를 출력

### 3. 파일 이동(mv)

```shell

$ mkdir tmp

$ mv a tmp
```
- a 파일이 tmp 폴더로 이동됨

### 4. 파일 삭제

```shell

$ rm tmp/a 

$ rmdir tmp/

```

- `rm` : 기본적으로 파일을 삭제할 때 
- `rmdir`: 디렉토리를 삭제할 때
  - 해당 디렉토리가 빈 상태에서만 사용 가능

### 5. 현재 디렉토리 확인(pwd)
```
$ pwd
/home/hwan/shell
```


### 6. 파일 권한(chmod)

```
chmod +r a # a 파일 읽기 권한 
chmod -r a # a 파일 읽기 권한 없음

chmod +w a # a 파일 쓰기 권한
chmod -w a # a 파일 쓰기 권한 없음

chmod +rw a # a 파일 읽고 쓰기 권한
chmod -rw a # a 파일 읽고 쓰기 권한 없음
```

### 7. sed(치환)
```shell
$ echo abcdabcd | sed 's/a/b/' 
bbcdabcd
```
- `sed` : 입력된 데이터를 앞에서부터 순서대로 스캔하면서 가장 처음 발견한 치환 대상의 문자열을 치환
- `s` : 문자의 치환을 수행한다는 의미

### 8. grep(검색)
> `grep` : 특정 파일에서 지정한 문자열이나 정규 표현식을 포함한 행을 출력해주는 명령어
> 
> grep [옵션][패턴][파일명]

```shell
$ seq 100 | grep "0" | xargs
10 20 30 40 50 60 70 80 90 100
```
- 인수로 지정한 0이 한 문자라도 있는 행은 모두 출력
- `seq 100` : 1~100 출력
- `xargs` : 값을 가로로 출력

```
$ seq 100 | grep "^8" | xargs
8 80 81 82 83 84 85 86 87 88 89

$ seq 100 | grep "8$" | xargs
8 18 28 38 48 58 68 78 88 98

$ seq 100 | grep "8." | xargs
80 81 82 83 84 85 86 87 88 89

$ seq 100 | grep "^10*$" | xargs
1 10 100


$ seq 100 | grep "[02468]$" | xargs
2 4 6 8 10 12 14 16 ..
$ seq 100 | grep "[^02468]$" | xargs
1 3 5 7 9 11 13 15 17 19 ..
```
- `^8` : 행의 맨 앞이 8
- `8$` : 행의 맨 끝이 8
- `8.` : `8` 과는 달리 한 자릿수 8을 포함하지 않고 8로 시작하는 두 자리 숫자
  - `.` : 어떤 한 문자 를 의미하는 메타문자

- ^10*$ : 1로 시작하고 0이 0개 이상, 끝이 0인 문자
  - `^1` : 1로 시작하는
  - `0*` : 0이 0개 이상
    - `*` : 0개 이상의 문자
  - `$` : 문자열의 끝

- `[02468]$` : 끝 문자가 0,2,4,6,8 중에 하나인 문자
- `[^02468]$` : 끝 문자가 0,2,4,6,8 을 제외한 다른 문자

#### -o 옵션
```shell
$ echo 오이 참외 냉이 수박 | grep -o "[^ ]이"  
오이
냉이
```
- `-o` : 정규표현식에 맞는 부분만 출력하는 옵션
- `[^ ]` : 공백 문자를 제외한 어떠한 문자
  - `[^ ]이` : 공백 문자를 제외한 문자에서 뒤에 '이' 가 따라오는 문자열


### 10. awk

> `awk` : 입력으로부터 레코드를 읽어서 지정한 구분자를 기준으로 필드를 분리, 데이터를 내가 원하는 포맷대로 쉽게 가공
- 데이터 조작에 특화된 언어
- 명령어 보단 프로그래밍 언어와 가깝다고 표현


```shell
$ echo "Hello World" | awk '{ print $0 }'
Hello World

$ echo "Hello World" | awk '{ print $1 }'
Hello

$ echo "Hello World" | awk '{ print $2 }'
World

$ echo "Hello,World" | awk -F "," '{ print $2 }'
World
```

- `$0` : 현재 레코드 전체
  - `$1` : 첫 번째 필드
  - `$2` : 두 번째 필드

- `-F` : 필드 구분자를 지정하는 옵션
  - `-F ","` : 필드 구분자를 쉼표로 사용
  - 때문에 4번째 명령어에서 , 가 아닌 World 가 출력


```
$ seq 5 | awk '$1%2{print $1}'
1
3
5
```

- 기본적으로 2로 나누어 떨어지지 **않을 때의 값**을 반환


```
$ seq 5 | awk '$1%2==0'
2
4
```
- `$1` : 첫 번째 필드

#### BEGIN, END
```shell
$ seq 5 | awk 'BEGIN{a=0}$1%2==0{print $1, "짝수"}$1%2{print $1, "홀수"}{a+=$1}END{print "합계",a}'
1 홀수
2 짝수
3 홀수
4 짝수
5 홀수
합계 15

```

- `BEGIN` : `awk` 가 첫 번째 행의 처리를 시작하기 전 상황에 매칭
- `END` : `awk`가 마지막 행의 처리를 마친 후 상황에 매칭 

1. `BEGIN{a=0}` : awk 시작 지점에 변수 a 를 0으로 초기화
2. `$1%2==0{print $1, "짝수"}` 는 $1%2가 0이면 (즉, 짝수이면) 해당 숫자와 "짝수" 문자열을 출력
3. `$1%2{print $1, "홀수"}` 는 $1%2가 0이 아니면 (즉, 홀수이면) 해당 숫자와 "홀수" 문자열을 출력
4. `{a+=$1}` : 출력된 모든 숫자를 더하여 a 에 저장 (홀수일 때만 실행되는 조건 아님)
5. `END{print "합계",a}` : 처리가 모두 끝난 후 변수 a 에 저장된 값을 출력

#### 정렬(sort), 중복 제거(uniq)

```shell
hwan@worker1:~/shell$ seq 5 | awk '{print $1%2? "a":"b"}' | sort
a
a
a
b
b
```
- sort 를 사용하여 정렬

```
$ seq 5 | awk '{print $1%2? "a":"b"}' | sort | uniq
a
b

$ seq 5 | awk '{print $1%2? "a":"b"}' | sort | uniq -c
      3 a
      2 b
```

- `uniq` : 중복제거
- `-c` : 카운트를 출력


### 11. xargs 를 사용한 일괄 처리
> `xargs` 는 출력을 가로로 나열하는 명령어로도 사용하긴 하지만, **명령어에 인수를 전달해서 실행 하는 명령어**로 주로 쓰인다.

```shell
# 1~4 까지의 파일을 모두 삭제
$ seq 4 | xargs rmdir
```

```shell
$ mkdir 1 3
$ ls
1  3
$ seq 4 | xargs -n2 mv
$ ls
2  4
```
- `xargs -n개수` : 입력된 문자열을 지정한 수만큼 명령어에 전달
  - 즉 (1,2) , (3,4) 를 묶어서 mv 에 전달
  - 1 -> 2 로 , 3 -> 4 로 mv 된다.

```shell
$ seq 4 | xargs -I@ mkdir dir_@
$ ls
dir_1  dir_2  dir_3  dir_4
```
- `-I` : 입력 라인의 각 항목에 대해 문자열을 사용할 수 있도록 해준다. ( @ 이외의 문자 모두 가능)

#### xargs 주의점
```shell
$ awk 'BEGIN{print "-e 1 2 3"}'
-e 1 2 3

$ awk 'BEGIN{print "-e 1 2 3"}' | xargs
1 2 3
```
- 원하던 결과와 다르게 -e 없이 출력되는 모습
  - `-e` 를 echo 옵션으로 해석하기 때문이다.
- 이러한 현상으로 xargs 는 신중히 사용해야 할 필요가 있다.(함부로 사용 X)


### 12 bash 를 사용한 메타 프로그래밍

#### 12.1 
```
$ seq 4 | awk '{print "mkdir " ($1%2? "odd_" : "even_") $1}'
mkdir odd_1
mkdir even_2
mkdir odd_3
mkdir even_4
```
- 단순히 이렇게 출력만 되던 것을 bash 파이프로 연결시킨다면?
```shell
$ seq 4 | awk '{print "mkdir " ($1%2? "odd_" : "even_") $1}' | bash
$ ls
even_2  even_4  odd_1  odd_3
```
- `| bash` 앞에서 얻은 출력,명령어들이 bash 에 입력되어 실행된다.

#### 3항 연산자가 아닌 if 문을 사용할 경우

```shell
$ seq 4 | awk '{if($1%2){a="odd_"}else{a="even_"}; print "mkdir " a $1}' | bash
```

#### 12.2 셸 스크립트
```shell

$ seq 4 | awk '{print "mkdir " ($1%2? "odd_" : "even_") $1}' > a
$ cat a
mkdir odd_1
mkdir even_2
mkdir odd_3
mkdir even_4

$ bash ./a  # a 파일을 실행
$ ls
a  even_2  even_4  odd_1  odd_3
```
- 출력 문장들을 a라는 파일에 저장하고 이를 bash 로 실행


---

## 실전 예제

### 1. 파일명 검색

#### 1.1 files.txt 파일에서 .exe 확장자를 가진 파일만 추출하기
```shell
$ grep '.\exe$' files.txt

$ cat files.txt | grep './exe$'
```

- `.` : 마침표는 정규표현식에서 `임의의 1문자와 일치한다` 라는 의미의 메타문자
  - 단 여기선 .exe 처럼 . 자체를 표현해야 하므로 `\` 역슬래시를 통해 메타문자가 아님을 구분한다.
- `\` : 역슬래시, 메타 문자에서 탈출하는 처리로 이스케이프 문자라고 부른다.


### 2. 파일명 일괄 변경
