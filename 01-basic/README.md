# Basic

### echo
- printf 처럼 화면 출력을 담당하는 명령어
- 일반적으로 쉘 스크립트, 배치파일에서 화면이나 파일로 상황을 알리는 문자열을 출력할 때 사용
- 쉘 스크립트의 변수나 터미널의 환경변수, 변수를 확인할 경우 주로 사용



### 1. 계산(bc)
```shell
$ echo '1+1' | bc
2
```
- `|` : **pipe**, 왼쪽 명령어의 출력을 오른쪽 명령어로 전달

### 2. 파일에 저장(>)
```shell
$ echo '1+1' | bc > a
```
- bc의 결과를 a 라는 파일에 저장
- `>` : 리다이렉트, 터미널 화면에 출력할 명령어의 결과를 다른 대상으로 돌린다.
- ls, cat 명령어등을 활용하여 새로 생긴 파일 a 확인 가능
  - `cat` : 지정한 파일의 내용을 그대로 출력
  - `ls -l` : `ls`보다 자세한 파일 정보를 출력

### 3. 파일 이동(mv)

```shell

$ mkdir tmp

$ mv a tmp
```
- a 파일이 tmp 폴더로 이동됨

### 4. 파일 삭제

```shell

$ rm tmp/a 

$ rmdir tmp/

```

- `rm` : 기본적으로 파일을 삭제할 때 
- `rmdir`: 디렉토리를 삭제할 때
  - 해당 디렉토리가 빈 상태에서만 사용 가능

### 5. 현재 디렉토리 확인(pwd)
```
$ pwd
/home/hwan/shell
```


### 6. 파일 권한(chmod)

```
chmod +r a # a 파일 읽기 권한 
chmod -r a # a 파일 읽기 권한 없음

chmod +w a # a 파일 쓰기 권한
chmod -w a # a 파일 쓰기 권한 없음

chmod +rw a # a 파일 읽고 쓰기 권한
chmod -rw a # a 파일 읽고 쓰기 권한 없음
```

### wc 명령어 (카운트)
| 옵션 | 내용                 |
|------|--------------------|
| -c   | 바이트(byte)의 수를 출력하는 옵션 |
| -l   | 행의 개수를 출력하는 옵션     |
| -L   | 가장 긴 행의 문자의 개수를 출력하는 옵션 |
| -w   | 단어의 개수를 출력하는 옵션    |

#### 가장 자주 쓰이는 -l 옵션
> [출력 명령어] | wc -l

```
$ ifconfig | wc -l
42

$ cat etc/services | wc -l
```

```shell

# 전체 문자 수 출력
$ wc -c syslog
```


### 리다이렉션
- 말 그대로 방향을 변경하는 것을 의미

| 형태         | 의미                        |
|------------|---------------------------|
| 명령 `<` 파일  | 파일의 내용을 명령어의 입력으로 사용한다.   |
| 명령 `>` 파일  | 명령어의 결과(표준 출력)를 파일에 덮어쓴다. |
| 명령 `>>` 파일 | 명령어의 결과를 파일에 추가한다.        |

#### `>` 연산자
```shell
$ 명령어 > file
```
- 명령어에서 나온 값을 file 에 기록 
- **처음부터 덮어 쓴다.**
#### `>>` 연산자
```shell
$ 명령어 >> file
```
- 명령어에서 나온 값을 file 에 기록
- **file 에 있는 기존 값에 이어서 기록한다.**
---

#### `<` 연산자
```shell
$ 명령어 < file
```
- file 의 내용을 명령어의 표준 입력으로 사용하는 의미

```shell
$ echo "리눅스 잘하고 싶어" > linux.txt

$ cat < linux.txt
리눅스 잘하고 싶어
```
- `>` 연산자를 이용해 echo 로 출력한 값을 linux.txt 파일을 생성하고 값을 쓴다.
- linux.txt 파일로부터 읽은 값을 cat의 표준 입력으로 사용한다.
  - cat linux.txt 와 동일한 의미

#### [표준 입출력, 표준 에러 출력 및 더 다양한 리다이렉션 조합](https://github.com/royroyee/shell/tree/main/02-variable-control#%ED%91%9C%EC%A4%80-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EB%B0%8F-%ED%91%9C%EC%A4%80-%EC%97%90%EB%9F%AC-%EC%B6%9C%EB%A0%A5)

## 7. sed(문자열 치환, 삭제, 출력)
- stream editor , 텍스트를 변형하고 출력하는 **텍스트 편집 도구**

### sed vs awk
- sed : 비대화형 모드의 텍스트 파일 에디터
- awk : c언어 형태의 문법을 가지는 필드 단위의 패턴 처리 언어

### sed 주요 옵션
| option | 설명                                    |
| ------ | --------------------------------------- |
| -e     | 조건식 스크립트를 직접 지정            |
| -f     | 조건식 스크립트가 기재된 파일을 지정    |
| -n     | 패턴이 일치하는 라인만 출력              |
| -r     | 확장 정규표현을 사용한 스크립트를 사용  |
| -i     | 수정한 내용으로 파일 덮어쓰기           |



```shell
$ echo abcdabcd | sed 's/a/b/' 
bbcdabcd
```
- `sed` : 입력된 데이터를 앞에서부터 순서대로 스캔하면서 가장 처음 발견한 치환 대상의 문자열을 치환
- `s` : 문자의 치환을 수행한다는 의미

### 주요 예시


```shell
# # 으로 시작하는 comment 행 모두 삭제
$ sed '/^#/d' text.txt

```

## 8. grep(검색)
> `grep` : 특정 파일에서 지정한 문자열이나 정규 표현식을 포함한 행을 출력해주는 명령어
> 
> grep [옵션][패턴][파일명]

```shell
$ seq 100 | grep "0" | xargs
10 20 30 40 50 60 70 80 90 100
```
- 인수로 지정한 0이 한 문자라도 있는 행은 모두 출력
- `seq 100` : 1~100 출력
- `xargs` : 값을 가로로 출력

```
$ seq 100 | grep "^8" | xargs
8 80 81 82 83 84 85 86 87 88 89

$ seq 100 | grep "8$" | xargs
8 18 28 38 48 58 68 78 88 98

$ seq 100 | grep "8." | xargs
80 81 82 83 84 85 86 87 88 89

$ seq 100 | grep "^10*$" | xargs
1 10 100


$ seq 100 | grep "[02468]$" | xargs
2 4 6 8 10 12 14 16 ..
$ seq 100 | grep "[^02468]$" | xargs
1 3 5 7 9 11 13 15 17 19 ..
```
- `^8` : 행의 맨 앞이 8
- `8$` : 행의 맨 끝이 8
- `8.` : `8` 과는 달리 한 자릿수 8을 포함하지 않고 8로 시작하는 두 자리 숫자
  - `.` : 어떤 한 문자 를 의미하는 메타문자

- ^10*$ : 1로 시작하고 0이 0개 이상, 끝이 0인 문자
  - `^1` : 1로 시작하는
  - `0*` : 0이 0개 이상
    - `*` : 0개 이상의 문자
  - `$` : 문자열의 끝

- `[02468]$` : 끝 문자가 0,2,4,6,8 중에 하나인 문자
- `[^02468]$` : 끝 문자가 0,2,4,6,8 을 제외한 다른 문자

### -o 옵션
```shell
$ echo 오이 참외 냉이 수박 | grep -o "[^ ]이"  
오이
냉이
```
- `-o` : 정규표현식에 맞는 부분만 출력하는 옵션
- `[^ ]` : 공백 문자를 제외한 어떠한 문자
  - `[^ ]이` : 공백 문자를 제외한 문자에서 뒤에 '이' 가 따라오는 문자열


### grep 주요 옵션
- `-i` : 검색 패턴에서 대소문자를 무시
- `-v` : 검색 패턴과 일치하지 않는 줄만 출력
- `-n` : 출력에 있는 각 일치 항목의 라인 번호를 출력
- `-c` : 검색 패턴과 일치하는 줄 수만큼만 출력
- `-r` : 하위 디렉토리에서 재귀적으로 검색
- `-l` : 검색 결과에서 일치하는 문자열이 포함된 파일의 이름만 출력(검색 대상 파일에서 특정 문자열이 존재하는 지 여부 판단)

```shell

#  log.txt 에서 "error" 패턴 검색
$ grep error log.txt 

# 여러 파일에서 "error" 패턴 검색
$ grep error file1.txt file2.txt file3.txt 

# 현재 디렉토리 및 하위 디렉토리의 모든 파일에서 "error" 패턴 검색
$ grep -r error .

# "error" 의 대소문자를 구분하지 않고 패턴 검색
$ grep -i error log.txt

# "error" 패턴과 일치하지 않는 라인만 출력
$ grep -v error log.txt

# 각 일치 항목의 라인 번호 출력
$ grep -n error log.txt

# 일치하는 라인의 개수 출력
$ grep -c error log.txt

# 현재 디렉토리에서 "hello" 문자열을 가진 모든 파일의 이름을 출력
$ grep -l "hello" *
```



## 10. awk

> `awk` : 입력으로부터 레코드를 읽어서 지정한 구분자를 기준으로 필드를 분리, 데이터를 내가 원하는 포맷대로 쉽게 가공
- 데이터 조작에 특화된 언어
- 명령어 보단 프로그래밍 언어와 가깝다고 표현



### awk - 필드와 레코드, NF NR
![필드와 레코드.png](..%2F..%2F..%2Ftest%2F%ED%95%84%EB%93%9C%EC%99%80%20%EB%A0%88%EC%BD%94%EB%93%9C.png)
출처 : https://jhnyang.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%9C%A0%EB%8B%89%EC%8A%A4-AWK-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%82%AC%EC%9A%A9%EB%B2%95


- awk 는 sed 명령어처럼 한 번의 하나의 행만 가지고 와서 수행
- 행의 첫 번째 열, 두 번째 열 이런 식으로 접근
  - `$0` : 행, 현재 작업하고 있는 레코드 데이터(전체 필드)
  - `$1` : 행의 첫 번째 열
- `NF` : 'the Number of Fields' 로 현재 레코드의 필드 개수
  - 위 표에선 NF = 4($4와 동일)
  - 작업하는 행 기준 **마지막 필드를 의미**
- `NR` : 현재 작업하고 있는 행의 순서
  - NR = 2 일 때 $1 -> 베인 

```shell
$ echo "Hello World" | awk '{ print $0 }'
Hello World

$ echo "Hello World" | awk '{ print $1 }'
Hello

$ echo "Hello World" | awk '{ print $2 }'
World

$ echo "Hello,World" | awk -F "," '{ print $2 }'
World
```

- `$0` : 현재 레코드 전체
  - `$1` : 첫 번째 필드
  - `$2` : 두 번째 필드

- `-F` : 필드 구분자를 지정하는 옵션
  - `-F ","` : 필드 구분자를 쉼표로 사용
  - 때문에 4번째 명령어에서 , 가 아닌 World 가 출력


```
$ seq 5 | awk '$1%2{print $1}'
1
3
5
```

- 기본적으로 2로 나누어 떨어지지 **않을 때의 값**을 반환


```
$ seq 5 | awk '$1%2==0'
2
4
```
- `$1` : 첫 번째 필드

```shell
awk -F: '{print $(NF-2)}' alternatives.log 
```
- 각 행을 : 으로 구분한 다음, 각 줄의 끝에서 3번째의 필드를 출력

### BEGIN, END
```shell
$ seq 5 | awk 'BEGIN{a=0}$1%2==0{print $1, "짝수"}$1%2{print $1, "홀수"}{a+=$1}END{print "합계",a}'
1 홀수
2 짝수
3 홀수
4 짝수
5 홀수
합계 15

```

- `BEGIN` : `awk` 가 첫 번째 행의 처리를 시작하기 전 상황에 매칭
- `END` : `awk`가 마지막 행의 처리를 마친 후 상황에 매칭 

1. `BEGIN{a=0}` : awk 시작 지점에 변수 a 를 0으로 초기화
2. `$1%2==0{print $1, "짝수"}` 는 $1%2가 0이면 (즉, 짝수이면) 해당 숫자와 "짝수" 문자열을 출력
3. `$1%2{print $1, "홀수"}` 는 $1%2가 0이 아니면 (즉, 홀수이면) 해당 숫자와 "홀수" 문자열을 출력
4. `{a+=$1}` : 출력된 모든 숫자를 더하여 a 에 저장 (홀수일 때만 실행되는 조건 아님)
5. `END{print "합계",a}` : 처리가 모두 끝난 후 변수 a 에 저장된 값을 출력

### 정렬(sort), 중복 제거(uniq)

```shell
hwan@worker1:~/shell$ seq 5 | awk '{print $1%2? "a":"b"}' | sort
a
a
a
b
b
```
- sort 를 사용하여 정렬

```
$ seq 5 | awk '{print $1%2? "a":"b"}' | sort | uniq
a
b

$ seq 5 | awk '{print $1%2? "a":"b"}' | sort | uniq -c
      3 a
      2 b
```

- `uniq` : 중복제거
- `-c` : 카운트를 출력


## 11. xargs 를 사용한 일괄 처리
> `xargs` 는 출력을 가로로 나열하는 명령어로도 사용하긴 하지만, **명령어에 인수를 전달해서 실행 하는 명령어**로 주로 쓰인다.

```shell
# 1~4 까지의 파일을 모두 삭제
$ seq 4 | xargs rmdir
```

```shell
$ mkdir 1 3
$ ls
1  3
$ seq 4 | xargs -n2 mv
$ ls
2  4
```
- `xargs -n개수` : 입력된 문자열을 지정한 수만큼 명령어에 전달
  - 즉 (1,2) , (3,4) 를 묶어서 mv 에 전달
  - 1 -> 2 로 , 3 -> 4 로 mv 된다.

```shell
$ seq 4 | xargs -I@ mkdir dir_@
$ ls
dir_1  dir_2  dir_3  dir_4
```
- `-I` : 입력 라인의 각 항목에 대해 문자열을 사용할 수 있도록 해준다. ( @ 이외의 문자 모두 가능)

#### xargs 주의점
```shell
$ awk 'BEGIN{print "-e 1 2 3"}'
-e 1 2 3

$ awk 'BEGIN{print "-e 1 2 3"}' | xargs
1 2 3
```
- 원하던 결과와 다르게 -e 없이 출력되는 모습
  - `-e` 를 echo 옵션으로 해석하기 때문이다.
- 이러한 현상으로 xargs 는 신중히 사용해야 할 필요가 있다.(함부로 사용 X)


### 12 bash 를 사용한 메타 프로그래밍

#### 12.1 
```
$ seq 4 | awk '{print "mkdir " ($1%2? "odd_" : "even_") $1}'
mkdir odd_1
mkdir even_2
mkdir odd_3
mkdir even_4
```
- 단순히 이렇게 출력만 되던 것을 bash 파이프로 연결시킨다면?
```shell
$ seq 4 | awk '{print "mkdir " ($1%2? "odd_" : "even_") $1}' | bash
$ ls
even_2  even_4  odd_1  odd_3
```
- `| bash` 앞에서 얻은 출력,명령어들이 bash 에 입력되어 실행된다.

#### 3항 연산자가 아닌 if 문을 사용할 경우

```shell
$ seq 4 | awk '{if($1%2){a="odd_"}else{a="even_"}; print "mkdir " a $1}' | bash
```

#### 12.2 셸 스크립트
```shell

$ seq 4 | awk '{print "mkdir " ($1%2? "odd_" : "even_") $1}' > a
$ cat a
mkdir odd_1
mkdir even_2
mkdir odd_3
mkdir even_4

$ bash ./a  # a 파일을 실행
$ ls
a  even_2  even_4  odd_1  odd_3
```
- 출력 문장들을 a라는 파일에 저장하고 이를 bash 로 실행


---

## 서브쉘(subshell)

### 서브쉘
- 쉘 안에서 다른 쉘을 실행시키는 것
- 터미널에서 작동 중인 배시와는 다른 프로세스로 작동하기 때문
- 부모 쉘의 환경 변수와 함수를 상속받지만, 서브쉘 안에서 만든 변수와 함수는 부모 쉘로 전달되지 않는다.

### 기본 예제
```shell
#!/bin/bash

mkdir dir1
mkdir dir2
mkdir dir3

for dir in dir1 dir2 dir3
do 
   cd $dir
   touch file.txt
   cd .. # 여기가 point!
done
```
- for 문에서 디렉토리를 바꾸고, 다시 부모 디렉토리를 돌아가기 위해 `cd ..` 를 수행하는 모습
- 이러한 부분은 스크립트가 복잡해질 수록 지저분해진다.

```shell
#!/bin/bash

mkdir dir1
mkdir dir2
mkdir dir3

for dir in dir1 dir2 dir3
do
  (cd $dir
  touch file.txt)
done
```

#### 참고
사실은 위의 스크립트를 더 최적화 해보면?(서브쉘 사용하지 않기)
```shell
#!/bin/bash

mkdir dir{1..3}
for dir in dir{1..3}; do
  (cd "$dir" && touch file.txt) # 서브쉘을 사용하지 않고 명령어 한 줄로 표현
done
```

---

## 실전 예제

###  파일명 검색

#### 1.1 files.txt 파일에서 .exe 확장자를 가진 파일만 추출하기
```shell
$ grep '.\exe$' files.txt

$ cat files.txt | grep './exe$'
```

- `.` : 마침표는 정규표현식에서 `임의의 1문자와 일치한다` 라는 의미의 메타문자
  - 단 여기선 .exe 처럼 . 자체를 표현해야 하므로 `\` 역슬래시를 통해 메타문자가 아님을 구분한다.
- `\` : 역슬래시, 메타 문자에서 탈출하는 처리로 이스케이프 문자라고 부른다.


###  파일명 일괄 변경

```
mv test test1
```
> mv : 파일 명을 바꾸거나 파일이나 디렉토리의 위치를 변경하고 싶을 때 사용
- test 파일 명을 test1으로 바꾼다.
- 만약 test1 이 디렉토리라면, test 파일이 test1 디렉토리로 옮겨진다.


> 파일명 변경에 특화된 명령어 rename 설치 : sudo apt install rename
```
ls -U | xargs -P2 rename 's/^/0000000/;s/0*([0-9]{7})/$1/'
```
- 작성 예정

### 특정 파일 삭제

#### 해당 디렉토리의 내용과 서브 디렉토리 모두 삭제하기
```shell
rm -rf tmp/*
```
- `-r` : 디렉토리를 재귀적으로 삭제 -> 디렉토리 내부의 모든 파일과 서브 디렉토리를 포함하여 삭제
- `-f` : 강제 삭제


#### 파일 생성
```shell
$ mkdir ./tmp
$ cd ./tmp
$ seq 1000 | sed 's/^/echo $RANDOM > /' | bash
```
- 1~1000 을 파일명으로 한 1000개의 파일들이 생성되고 그 파일안에 RANDOM 변수가 무작위로 입력된다. (0~32767)

#### 위에서 생성한 파일 중에, 10 이라는 값을 가진 파일만 삭제하기
```shell

# 10을 갖는 파일만 찾는 명령어

$ grep -l '^10$' * # 해당 디렉토리에서만 찾을 경우
$ grep -l '^10$' -R # 재귀적으로 하위 디렉토리 파일까지 찾아야 하는 경우

# 삭제 명령어
$ grep -l '^10$' -R | x args rm
```

- 그냥 rm 이 아니라 xargs 가 필요한 이유 : `rm` 명령어에 직접 파이프로 출력 결과를 전달하면, rm 명령어는 파일을 삭제할 인자를 받지 못한다.
  - 출력 결과를 `xargs` 명령어로 전달하면, 출력 결과를 `rm` 명령어에 인자로 전달이 가능하다.

---

## awk, sed 활용

### 설정 파일에서 정보 추출

#### 첫 번째 열에 pool 이라고 쓰인 행의 서버명 추출하기
```shell

# 첫 번째 열이 pool 이라고 쓰인 행 추출
$ cat ntp.conf | awk '$1=="pool"'


# 해당 행에서 서버 명(두 번째 필드만 추출하기)
$ cat ntp.conf | awk '$1=="pool"' | awk '{print $2}'
```
- grep 명령어에서 사용하는 `$`은 정규표현식으로, 문자열의 끝을 의미하지만 awk 명령어에서 $ 는 해당 라인의 필드를 의미한다.

### awk, for문 사용해보기

#### 터미널에 모양 출력
```shell
$ seq 5 | awk '{for(i=1;i<$1;i++){printf " "};print "x"}'
x
 x
  x
   x
    x
```
1. seq 로 1~5 까지 숫자를 출력한다.
2. 그 숫자만큼 awk 를 통해 공백을 출력한다. {printf " "}
3. 그 다음 x 를 출력한다.

### awk, 표 계산(simple)

#### kakeibo.txt
```
20190901 제로컵오제키 10000
20190902 *양배추2통 130
20191105 외식 13000
20191106 스트롱원 13000
20191106 *네루네루네루네루 30
20190912 외식 13000
```
- 해당 표에서 소비세를 계산해야 할 때
- * : 소비세 8%
- 나머지 : 소비세 10%
- 10월 이전은 8%

#### 1. 표에 소비세율의 열을 추가하기(표의 값을 바꾸지 않고 단순 print)
```shell
$ cat kakeibo.txt | awk {'tax = ($1<"20191001" || $2~/^*/)? 1.08 : 1.1; print $0, tax}'

20190901 제로컵오제키 10000 1.08
20190902 *양배추2통 130 1.08
20191105 외식 13000 1.1
20191106 스트롱원 13000 1.1
20191106 *네루네루네루네루 30 1.08
20190912 외식 13000 1.08
```
- 10월 이전과 *가 붙어있으면 8% 증가, 나머지는 10% 증가를 수행
- 해당 명령어는 단순히 print 만 수행(표의 값을 바꾸진 않음)

#### 2. 소비세율 구하기
```shell
$ cat kakeibo.txt | awk {'tax = ($1<"20191001" || $2~/^*/)? 1.08 : 1.1; print $0, tax}' | awk '{print int($3*$4)}'
10800
140
14300
14300
32
14040
```
- int : 주어진 숫자를 정수로 변환하는 함수

### 로그 집계
