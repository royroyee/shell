# 변수와 제어 구문, 명령어 입출력 조작 파악하기


---


## 표준 입출력 및 표준 에러 출력

[참고자료](https://inpa.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-devnull-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98-%EA%B8%B0%ED%98%B8-%EC%A2%85%EB%A5%98)

### 파일 디스크립터
- 표준 입력과 표준 출력, 표준 에러를 쉘이나 시스템 프로그래밍에서는 숫자로도 표현이 가능한데 이를 **파일 디스크립터** 라고 한다.
- 쉘은 작업 중 필요한 파일에 일련번호를 붙여서 관리한다.
  - 이 일련번호가 파일 디스크립터이며, 표준 입출력 장치도 이 일련번호로 제어된다.

| 파일디스크립터(일련번호) | 이름   | 용도                                 | 표준장치 |
|-----------------------|--------|--------------------------------------|----------|
| 0                     | stdin  | 명령어에 입력될 내용을 저장         | 키보드   |
| 1                     | stdout | 명령어에서 출력될 내용을 저장     | 화면     |
| 2                     | stderr | 명령어에서 출력될 에러메시지를 저장 | 화면     |

### 다양한 리다이렉션 기호 조합
[리다이렉션이란?](https://github.com/royroyee/shell/tree/main/01-basic#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98)

```shell

$ 명령 >& 파일명 # 명령이 실행된 표준 출력의 결과와 에러를 파일로 출력(덮어쓴다.)

$ 명령 >>& 파일명 # 명령이 실행된 표준 출력의 결과와 에러를 파일에 이어서 출력(덧붙인다.)

$ 명령 >! 파일명 # 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과를 파일로 출력(덮어쓴다)

$ 명령 >>! 파일명 # 파일의 존재 유무와 상관없이 생성하고 파일에 덧붙여 출력 

$ 명령 >&! 파일명 # 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과와 에러를 파일로 출력

$ 명령 >>&! 파일명 # : 파일의 존재 유무와 상관없이 생성하고 명령이 실행된 표준 출력의 결과와 에러를 파일에 덧붙여 출력
```

```shell
$ 명령 1> 파일명 # : 일련번호 1쓰나 안쓰나 어쨋든 출력을 의미하기에 '명령 > 파일명' 와 같다. 

$ 명령 2> err.txt # : 만일 명령을 실행하다 에러가 나면, 에러를 화면에 출력하지 말고 파일에 기록하도록 재지정

$ 명령 2>> err.txt # : 오류가 나면 에러내용을 계속 파일에 덧붙여 추가한다.
```

```shell
$ 명령 2>&1 파일명 # : 표준에러를 표준출력 동작으로 재지정 하라는 뜻
```
```shell
>|            # : 출력을 리다이렉션 할 때 NOCLOBBER 설정을 무시한다
<>  filename  # : 장치 파일(/dev)이면, 표준 출력, 표준 입력 등에 모두 사용한다.
```


### 리다이렉션 실습
```shell
$ ls > log.txt 
```
- ls 로 출력하는 표준 출력 동작을 log.txt 로 재지정 하여 출력(리다이렉션)

```shell
$ ls -ERR > log.txt # ERR : 일부로 에러를 출력

$ cat log.txt
(empty)
```
-  log.txt 는 비어있음(이전에 출력한 ls 내용도 사라짐)

#### 에러도 파일에 저장하고 싶다면?
```
$ ls -ERR 2> log.txt
```
- `2>` : 에러가 나면 **에러를 화면에 출력하지 않고 파일에 출력(덮어쓰기)**

#### 그러면 `>2` 로도 충분할까? 

```shell
$ ls 2> log.txt
'!'   a   b   even_2   even_4   log.txt   odd_1   odd_3   shell-oneliner   test.txt   tmp
$ cat log.txt 
hwan@worker1:~/shell$ 
```

- ls 명령어가 화면에 출력되고, log.txt 내용은 다시 사라졌다.

### 표준 출력 과 표준 에러의 차이(>2&1)
- 표준 출력 : 정상적인 명령어의 결과 내용의 출력을 화면에서 파일로 바꾼 것
- 표준 에러 : 오류메시지 출력을 화면에서 파일로 바꾼 것

- `2>` : 표준 에러 재지정은 **오류메세지만 취급** -> **정상적인 명령에 대해서 아무런 작업을 수행하지 않음**

#### 출력을 파일에 저장하되, 에러도 저장하게 하려면?
```shell
$ ls > log.txt 2> log.txt
```
- ls > log.txt : 표준 출력을 log.txt 파일로 리다이렉션(재지정)
- 2> log.txt : 에러가 날 경우 log.txt 파일로 리다이렉션(재지정)

#### 명령어가 너무 긴데? `2>&1`
```shell
$ ls > log.txt 2>&1
```
- ls > log.txt : 표준 출력을 log.txt 파일로 리다이렉션
- 2>&1 : 표준 에러를  `&1` 로 리다이렉션을 의미
  - `&1` : 숫자 1을 & 기호를 통해 표준 출력 일련번호로 인식하게 해주는 설정 (1:stdout)
  - 즉 `>2` 에 의해 에러 메시지를 화면에 띄우지 않고 `&1` 리다이렉션 하는데, `&1` 표준 출력을 의미한다.
  - 이미 표준 출력은 log.txt 로 리다이렉션된 상태이므로, 에러도 log.txt 파일에 저장된다.

### /dev/null 이해 
위의 리다이렉션, 표준 출력 및 에러를 이해했다면 자주 볼 수 있는 이 명령어도 이해할 수 있다.
```
$ /script.sh > /dev/null 2>&1
```
- `/dev/null` : 이 경로에 보내지는 모든 파일과 데이터들은 없애 화면에 표시되지 않는다.(블랙홀)
  - 즉 특정 명령어를 실행할 때 출력이 필요 없는 경우에 `/dev/null` 로 리다이렉션 시킨다!

- **때문에 /dev/null 2>&1 은 출력결과와 에러 내용도 포함해서 모두 /dev/null 로 리다이렉션 시켜 버려버린다는 의미가 된다.**

---

## 셸과 변수

[Bash 비교 연산자]()

### 변수명=값
```
$ a=foo
```

#### 공백은 작성하지 않아야 한다.
```
$ a = foo
```
- 등호 좌우 어느 쪽에도 공백을 포함하지 않아야 한다.
  - 공백이 있으면 a 를 명령어, = foo 를 각각 인수라고 판단한다.

### $변수명 , ${변수명}
- 변수 값을 사용하고 싶을 땐 $변수명 , ${변수명} 처럼 작성한다.
  - 값 문자열로 대체된다.
```shell
$ echo $SEHLL
/bin/bash
```
- 단순히 SEHLL 변수를 문자열로 바꾸어 echo 실행

## 문자열 연결과 치환
```shell

# 준비사항
$ a=리눅스
$ b=마스터

$ c=$a$b; echo $c
리눅스마스터

$ a+=$b; echo $a
리눅스마스터

$ b=${a:0:1}${a:2:2}; echo $b
리스마
```
- {변수명:시작문자 위치:길이}
  - {a:0:1} : 0번째 부터 1개의 문자

### 치환
- ${변수명/치환 대상 문자열/치환 후 문자열}
```
$ b=백엔드

$ b=${b/백엔드/클라우드}; echo $c
클라우드
```

## 변수를 사용한 계산(산술 확장)
- 문자열이 아닌 숫자를 다루어 계산이 필요할 때 bash 에서는 `$(( ))` 안에 계산식을 쓴다.
  - 이 기호를 **산술 확장** 이라고 한다.
  
```shell
$ a=6
$ b=2

$ echo $((a+b)) $((b-a)) $((a*b)) $((a/b)) $((a%b))
8 -4 12 3 0
```
- 괄호 안에는 `$` 를 붙일 필요는 없다. (붙여도 가능하다)

## 따옴표와 변수

### `` 작은 따옴표

- {print 1+1} 과 같이 **공백을 포함한 인수를 하나로 모아 인수로 전달**한다.
- $1 등 `awk`의 변수가 셸의 변수로 해석되는 것을 방지한다.
- **문자열을 그대로 출력**한다.

### "" 큰 따옴표
- bash의 변수는 해석된다.
- `$`, `(역 따옴표) , \ , ~(홈 디렉토리) 변수들을 해석한다.
  - 이 문자 외에는 대부분 해석을 하지 않는다.

### `` 역 따옴표
- 명령어를 실행한 결과를 출력
- 보통 어떤 명령어 결과값을 담거나 출력할 때 사용

#### 차이

#### 공통
```shell
$ p=pen 
$ re="" # 길이가 0인 문자열
```
```shell
$ echo $p "$p" '$p'
pen pen $p

$ echo "This is a $p" 'That is a %p'
This is a pen That is a %p
```
- 작은 따옴표는 $ 문자를 해석하지 않은 것을 알 수 있다.

#### 가장 깔끔한 방법? -> 큰 따옴표와 ${} 사용하기
````shell
$ echo "This is a ${p}cil. $pcil"
This is a pencil.
````
- 큰따옴표와 중괄호를 사용하는 것이 에러를 방지하기에 가장 좋은 방법이다.
- 큰 따옴표를 쓰더라도 중괄호를 하지 않고 $pcil 로 작성하면 의도치 않은 값이 출력될 수 있다.
  - 여기서는 $pcil 자체를 변수로 판단하기 때문에 아무 값도 출력되지 않음


## bash 배열 및 연관 배열

### 배열 생성
```shell
$ a=(100 200 hello)

$ a=("hello" "world")
```
- 등호 양쪽에 공백이 없도록 주의

### 인덱싱
```
$ a=(100 200 300)
$ echo ${a[0]}
100
```
- `${변수이름[인덱스]}` 형태 이용
- 중괄호는 필수이다. (그렇지 않으면 a[0] 자체를 인수로 판단함)



### 연관 배열
**연관 배열 : 인덱스 대신 key를 이용하여 원소에 접근하는 배열**
- 위에서 다룬 일반적인 배열은 인덱스 배열 이라고 함
- `declare -A` 명령어 이용 (명시적 선언이 필수다.)

```shell
$ declare -A b # b 라는 연관 배열 선언

$ b["SHELL"]=$SHELL" # 자유롭게 사용 가능
```

### 배열의 전체 값 얻기
총 4가지 방법 존재
- `${변수이름[@]}`: 인덱스가 들어갈 자리에 @
- `${변수이름[*]}`: 인덱스가 들어갈 자리에 *
- `"${변수이름[@]}"`: 큰따옴표("")로 묶은 뒤 인덱스가 들어갈 자리에 @
- `"${변수이름[*]}"`: 큰따옴표("")로 묶은 뒤 인덱스가 들어갈 자리에 *

> 추천 방법 : ${변수이름[@]}
- 이유와 자세한 내용은 아래 for문에서 다룸

### 배열의 크기 얻기
- `${#배열명[@]}`
  - `#` : 변수나 배열의 값의 길이를 구할 때 사용되는 parameter expansion
  - `[@]` : 배열 내 모든 요소
- 단, 모든 인덱스를 구하는 것이 아닌, **순전히 배열에 들어있는 값의 개수만 구한다.**

```shell
$ echo "${#b[@]}"
3
```

### 배열의 값 삭제
- `unset` 명령어 이용
```shell
$ a=(100 200 300 400 500)

$ unset a[1] # 배열의 1번 인덱스(200)를 삭제

$ echo "${a[@]}"
100 300 400 500

$ unset a # 배열 전체 삭제
```

## 반복과 종료 상태

### 괄호, 이중 괄호
``
(( expression ))
``
- 수식을 계산할 때는 이중 괄호를 사용한다.
- 이중 괄호 안에 수식을 쓰면 수식이 계산된다.



````
$ set aa bb cc # 배시에 인수 3개를 등록한다. set 에 대해선 이후 다룸
$ echo $2
bb
````
### for 문(기초)

```shell
for [ 배열_아이템 ] in [ 배열 ]
do
   명령1
   ${배열_아이템}
done
```

#### 예제
```shell
for vTime in {1..100}
do
  echo ${vTime}
done
```

```
$ for x in "$1" "$2" "$3"; do echo $x; done
aa
bb
cc
```

### while 문(기초)
```shell
while [ 조건 ]
do
   명령1
   명령2
done
```

```shell
while [ 조건 ]; do 명령1;명령2; done
```
#### 예시
```
#!/bin/bash

number=0

while [ $number -le 2 ]
do
  echo "Number: ${number}"
  ((number++))
done
```

```shell
$ while [ $number -le 2 ]; do echo "Number: ${number}"; ((number++)); done
```
- (()) 이중 괄호를 이용하여 수식을 계산한다.
  - (number++) 로 작성하면 오류. (수식을 계산하지 않음)


```
$ seq 3 | while read x; do printf "%s " $x; done
1 2 3
```
#### 양 100마리를 1초마다 세어서 표시하는 예제
```shell
#!/bin/bash

n=1
while [ $n -le 100 ]
do 
    echo "양 $n마리"
    n=$((n+1))
    sleep 1
done
```


#### 무한 루프
```shell
number=0

while :
do
  if [ $number -gt 2 ]; then
    break
  fi

  echo "Number: ${number}"
  ((number++))
done
```
- `while : ` 로 표현하면 무한 루프
- if 문을 이용하여 2보다 커지면 while 문 탈출

### if 문
```shell
if [조건식]; then // if 문 시작

...
elif

...
else
...

fi // if문 종료
```
- if와 대괄호 사이는 반드시 한 칸씩 띄어주어야 한다.
  - ex) if [ 0 == 0 ]

### if문 문자열 비교 옵션
 옵션 | 사용법 | 설명
--- | --- | ---
 없음 | `if [ 문자 ]` | 빈 문자열이 아니라면 참.
 `=` 또는 `==` | `if [ 문자 = 문자 ]` | 두 문자열이 같다면 참.
 `!=` | `if [ 문자 != 문자 ]` | 두 문자열이 같지 않다면 참.
 `-n` | `if [ -n 문자 ]` | 문자열이 null(빈 문자열)이 아니라면 참.
 `-z` | `if [ -z 문자 ]` | 문자열이 null(빈 문자열)이라면 참.

### if문 기본 옵션
옵션 | 사용법 | 설명
--- | --- | ---
-d | `[ -d 파일 ]` | 파일이 디렉토리면 참
-e | `[ -e 파일 ]` | 파일이 존재하면 참
-L | `[ -L 파일 ]` | 파일이 심볼릭 링크면 참
-r | `[ -r 파일 ]` | 파일이 읽기 가능하면 참
-s | `[ -s 파일 ]` | 파일의 크기가 0보다 크면 참
-w | `[ -w 파일 ]` | 파일이 쓰기 가능하면 참
-x | `[ -x 파일 ]` | 파일이 실행 가능하면 참


### case 문
```shell
case $operator in
  "+") 
    result=$((num1+num2))
    ;;
  
  ...
  
  *)
      echo "올바르지 않은 연산자"
      exit 1
      ;;
esac 
```
- `:` 가 아닌 `)` 으로 분기를 나타낸다.
- `;;` 으로 조건의 끝을 나타낸다.
- *) : default 를 의미
- esac : 단순히 case 을 뒤집은 것으로 끝남을 의미

---

## 존재하지 않는 파일의 초기화
```shell
$ [ -e unfile ] || touch unfile
```
- `-e` 옵션 : 파일 유무 확인 옵션
- unfile 이 존재하지 않으면 touch 명령어가 실행된다.


## 문자 유형 변환

### 대문자 변환
`${변수명^^}` 

```
$ echo I am a perfect human | (read a; echo ${a^^})
I AM A PERFECT HUMAN
``` 


## BASH IFS
IFS 는 Internal Field Separator 의 약자로, 외부프로그램을 실행할 때 입력되는 문자열을 나눌 때 기준이 되는 문자를 정의하는 환경 변수

- 디폴트 값 : 공백/탭/개행 문자

```shell
#!/usr/bin/bash

mystring="foo bar baz rab"

for word in $mystring; do
    echo Word : "$word"
done

$ bash script.sh
Word: foo
Word: bar
Word: baz
Word: rab
```
- IFS 는 환경변수로 기본 값이 공백으로 되어있기 때문에 해당 for문에서 공백으로 구분되어 출력됨

```shell
PROGRAMMING="
go programming
c programming
java programming
" # 개행이 있는 문자열

echo "---------------------"

for p in $PROGRAMMING; do
   echo $p #IFS 는 먼저 공백으로 구분 -> 없으면 개행으로 구분
done

# IFS를 줄바꿈으로 변경
OLD_IFS="$IFS"
IFS=$'\n'

echo "---------------------"
for p in $PROGRAMMING; do
  ehco $p
done

IFS="$OLD_IFS" # 환경변수이기 때문에 항상 돌려주는 습관 필요



$ bash test.sh

-------------------------
go
programming
c
programming
java
programming
-------------------------
go programming
c programming
java programming
```
- IFS 는 환경변수이므로 롤백 해주는 것이 중요하다.
